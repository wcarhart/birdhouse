#!/bin/bash
set -e

source koi
koiname=birdhouse
koidescription="Passive tweet watcher from the command line"

# colors
__reset="\033[0m"
__bold="\033[1m"
__italics="\033[3m"
__lightgrey="\033[90m"
__yellow="\033[93m"
__teal="\033[96m"

# ==================== INTERNAL FUNCTIONS ====================

function __verifyjq {
	# verify jq is installed
	if ! $(type jq > /dev/null 2>&1); then
		__errortext "$koiname: err: 'jq' is not in the PATH (see: https://stedolan.github.io/jq/)"
		return 1
	fi
}

function __verifycredentials {
	# verify the Twitter API key, API secret key, and generated OAuth2 bearer token are valid
	if [[ ! -f ~/.birdhouse/token ]] ; then
		__errortext "$koiname: warning: missing OAuth bearer token, attempting to rectify"
		if [[ ! -f ~/.birdhouse/auth || ! -f ~/.birdhouse/secret ]] ; then
			__errortext "$koiname: err: missing credentials"
			__errortext "  use 'birdhouse init --force' to reinitialize"
			return 1
		fi
		__generatebearertoken
	fi
}

function __generatebearertoken {
	# generate a OAuth2 bearer token from a Twitter API key and API secret key
	local __apikey="`cat ~/.birdhouse/auth`"
	local __secretkey="`cat ~/.birdhouse/secret`"

	curl -s -u "${__apikey}:${__secretkey}" --data 'grant_type=client_credentials' 'https://api.twitter.com/oauth2/token' > ~/.birdhouse/temp
	accesstoken=`jq -r '.access_token' ~/.birdhouse/temp`

	if [[ "$accesstoken" == "null" ]] ; then
		__errortext "$koiname: err: unable to verify your credentials, could not generate bearer token"
		__errortext "  use 'birdhouse regenerate'     to reattempt with the existing API key and secret key"
		__errortext "  use 'birdhouse init --force'   to start over with a new API key and secret key"
		return 1
	fi

	echo "$accesstoken" > ~/.birdhouse/token
	if [[ -f ~/.birdhouse/temp ]] ; then
		rm -rf ~/.birdhouse/temp
	fi
}

function __twurl {
	# Twitter cURL with proper authentication
	# $1 is the Twitter URL to compute
	local nocheck=0
	if [[ "$1" == "-n" ]] ; then
		local nocheck=1
		shift
	fi
	local token="`cat ~/.birdhouse/token`"
	local response=`curl -s -H "Authorization: Bearer ${token}" "$1"`

	if [[ "$nocheck" -eq 0 ]] ; then
		if [[ `jq -r 'if type=="object" then "object" else "" end' <<< "$response"` == "object" ]] ; then
			if [[ `jq 'has("errors")' <<< "$response"` == "true" ]] ; then
				__errortext "$koiname: err: Twitter API error `jq '.errors[0].code' <<< "$response"`"
				__errortext "  `jq -r '.errors[0].message' <<< "$response"`"
				return 1
			fi
		fi
	fi
	echo "$response"
}

function __gettweet {
	# get a specific tweet
	# $1 is the tweet's ID
	local response=`__twurl "https://api.twitter.com/1.1/statuses/show.json?id=${1}&tweet_mode=extended"`
	echo "$response"
}

function __iso2epoch {
	# convert a ISO-8601 datetime stamp (from Twitter) to epoch time
	# $1 is an ISO-8601 datetime stamp in the format:
	#   %a %b %d %X %z %Y
	local epochtime=`date -j -u -f '%a %b %d %X %z %Y' "$1" '+%s' || date -u -d "$1" +'%s'`
	echo "$epochtime"
}

function __resolvetime {
	# resolve epoch time to a prettified English statement
	# $1 is an ISO-8601 datetime stamp in the format:
	#   %a %b %d %X %z %Y
	currenttime=`date +'%s'`
	postedtime=`__iso2epoch "$1"`

	timediff=$(( $currenttime - $postedtime ))
	if [[ $timediff -lt 60 ]] ; then
		echo `__pluralize $timediff second`
	elif [[ $timediff -lt 3600 ]] ; then
		timediff=$(( $timediff / 60 ))
		echo `__pluralize $timediff minute`
	elif [[ $timediff -lt 86400 ]] ; then
		timediff=$(( $timediff / 3600 ))
		echo `__pluralize $timediff hour`
	elif [[ $timediff -lt 604800 ]] ; then
		timediff=$(( $timediff / 86400 ))
		echo `__pluralize $timediff day`
	elif [[ $timediff -lt 2592000 ]] ; then
		timediff=$(( $timediff / 604800 ))
		echo `__pluralize $timediff week`
	elif [[ $timediff -lt 31556952 ]] ; then
		timediff=$(( $timediff / 2592000 ))
		echo `__pluralize $timediff month`
	elif [[ $timediff -lt 315569520 ]] ; then
		timediff=$(( $timediff / 31556952 ))
		echo `__pluralize $timediff year`
	elif [[ $timediff -lt 3155695200 ]] ; then
		timediff=$(( $timediff / 315569520 ))
		echo `__pluralize $timediff decade`
	else
		echo `__pluralize $timdiff century`
	fi
}

function __pluralize {
	# pluralize a unit (add an 's')
	# $1 the quantity
	# $1 the unit to pluralize
	local result="$1 $2"
	if [[ $1 -ne 1 ]] ; then
		result="${result}s"
	fi
	echo "$result"
}

function __cleantext {
	# clean text into terminal friendly format
	# $@ is the text to clean

	local __content=$(echo "$@" | sed \
	-e 's/&gt;/>/g' \
	-e "s/&#x27;/'/g" \
	-e 's/&quot;/"/g' \
	-e 's/\&amp;/\&/g' \
	-e 's/<i>/_/g' \
	-e 's;</i>;_;g' \
	-e 's/<b>/**/g' \
	-e 's;</b>;**;g' \
	-e 's/<strong>/**/g' \
	-e 's;</strong>;**;g' \
	-e 's~&#x2F;~/~g' \
	-e 's~<a .*\(href=\\"[^\\"]*\).*</a>~\1~g' \
	-e 's~href=\\"~~g' \
	-e 's~<a .*\(href="[^"]*\).*</a>~\1~g' \
	-e 's~href="~~g')
	if [[ `uname -s` == "Darwin" ]] ; then
		__content=$(echo "$__content" | sed \
		-e 's/<p>/\\\n\\\n/g' \
		-e 's/<br>/\\\n\\\n/g' \
		-e 's/<pre><code>/```\\\n/g' \
		-e 's;</code></pre>;\\\n```\\\n;g' \
		-e 's/<code>/```\\\n/g' \
		-e 's;</code>;\\\n```\\\n;g')
	else
		__content=$(echo "$__content" | sed \
		-e 's/<p>/\n\n/g' \
		-e 's/<br>/\n\n/g' \
		-e 's/<pre><code>/```\n/g' \
		-e 's;</code></pre>;\n```\n;g' \
		-e 's/<code>/```\n/g' \
		-e 's;</code>;\n```\n;g')
	fi
	__resolvetcolinks "$__content"
}

function __resolvetcolinks {
	# translate https://t.co links into destination URLs
	# $1 is the tweet text in which to resolve t.co links
	local __content="$1"
	local foundlinks=( `grep -o 'https://t.co/[a-zA-Z0-9]*' <<< "$__content"` )
	for link in "${foundlinks[@]}" ; do
		resultinglink=`curl -s -D - "$link" | grep location: | sed 's/^location: //g' | tr '\r' ' '`
		resultinglink=`sed 's/\&/%26/g' <<< "$resultinglink"`
		resultinglink=`sed 's/~/%7e/g' <<< "$resultinglink"`
		__content=`sed -- 's~'"$link"'~'"$resultinglink"'~g' <<< "$__content"`
		__content=`sed 's/%26/\&/g' <<< "$__content"`
		__content=`sed 's/%7e/~/g' <<< "$__content"`
	done
	echo "$__content"
}

function __printtweet {
	# pretty print a tweet with proper indentation
	# $1 is the tweet text body
	# $2 is the tweet author (handle)
	# $3 is the tweet datetime stamp
	# $4 is the indent length
	# $5 is the link text

	# handle indent
	local indent=
	if [[ $4 -gt 0 ]] ; then indent="`printf "%0.s " $(seq 1 $4)`" ; fi

	# handle text
	local text="$1"
	if [[ "$1" == "" || "$1" == "null" ]] ; then
		text="<deleted>"
	fi

	# handle author
	local author="$2"
	if [[ "$2" == "" || "$2" == "null" ]] ; then
		author="<deleted>"
	fi

	# handle timestamp
	if [[ "$3" == ABSOLUTE* ]] ; then
		local epochtime=`__iso2epoch "${3#*ABSOLUTE}"`
		local e=( `date -j -f '%s' "$epochtime" '%a %b %d %X %z %Y'|| date -d "$epochtime" +'%a %b %d %X %z %Y'` )
		local timestr="| ${__yellow}${e[1]} ${e[2]}, ${e[5]} @ ${e[3]}${__reset}"
	elif [[ "$3" == "" || "$3" == "null" ]] ; then
		local timestr=""
	else
		local timestamp="`__resolvetime "$3"` ago"
		local timestr="| ${__yellow}${timestamp}${__reset}"
	fi

	# handle link
	local linktext=
	if [[ $5 != "" ]] ; then
		linktext="| ${__lightgrey}$5${__reset}"
	fi

	if [[ "$indent" == "" ]] ; then
		echo -n "➤ "
		echo -e "${__teal}${author}${__reset} ${timestr} ${linktext}" | sed "s/^/${indent}/"
		indent="`printf "%0.s " $(seq 1 2)`"
	else
		echo -e "${__teal}${author}${__reset} ${timestr} ${linktext}" | sed "s/^/${indent}/"
	fi
	echo -e "${__italics}`__cleantext "$text"`${__reset}" | fold -w 80 -s | sed "s/^/${indent}/"
}

function __listenexit {
	echo " exiting..."
}

function __processtweets {
	# process a tweet JSON response
	# $1 is the JSON response to process
	# $2 is whether or not to use an absolute timestamp - 0 is relative, 1 is absolute
	# $3 is whether or not to include a link to the tweet - 0 is no, 1 is yes

	local response="$1"
	local absolute="$2"
	local link="$3"

	for row in $(jq -r '.[] | @base64' <<< "$response") ; do
		function __jq {
			base64 --decode <<< "$row" | jq -r ${1}
		}
		if [[ `jq 'has("retweeted_status")' <<< "$(base64 --decode <<< "$row")"` == "true" ]] ; then
			local text="RT @`__jq '.retweeted_status.user.screen_name'` `__jq '.retweeted_status.full_text'`"
		else
			local text="`__jq '.full_text'`"
		fi
		local dt="`__jq '.created_at'`"
		if [[ "$absolute" -eq 1 ]] ; then
			dt="ABSOLUTE$dt"
		fi
		local handle="@`__jq '.user.screen_name'`"
		if [[ $link -eq 1 ]] ; then
			local linktext="https://twitter.com/${handle:1}/status/`__jq '.id_str'`"
		fi
		local replytweet="`__jq '.in_reply_to_status_id_str'`"
		if [[ "$replytweet" != "null" ]] ; then
			local __response=`__twurl -n "https://api.twitter.com/1.1/statuses/show.json?id=${replytweet}&trim_user=true&tweet_mode=extended"`
			local __author="`__jq '.in_reply_to_screen_name'`"
			local __text="`jq -r '.full_text' <<< "$__response"`"
			local __dt="`jq -r '.created_at' <<< "$__response"`"
			if [[ "$absolute" -eq 1 ]] ; then
				__dt="ABSOLUTE$__dt"
			fi
			if [[ $link -eq 1 ]] ; then
				local __linktext="https://twitter.com/${__author}/status/${replytweet}"
			fi
			__printtweet "$__text" "@$__author" "$__dt" 0 "$__linktext"
			__printtweet "$text" "$handle" "$dt" 4 "$linktext"
		else
			__printtweet "$text" "$handle" "$dt" 0 "$linktext"
		fi
		echo
	done
}

function __resolvelanguage {
	# resolve a language to an ISO-361-1 language code
	# $1 is the string to resolve
	local codes=( Afar:aa Abkhazian:ab Afrikaans:af Akan:ak Albanian:sq Amharic:am Arabic:ar \
		Aragonese:an Armenian:hy Assamese:as Avaric:av Avestan:ae Aymara:ay Azerbaijani:az \
		Bashkir:ba Bambara:bm Basque:eu Belarusian:be Bengali:bn Bihari:bh Bislama:bi \
		Bosnian:bs Breton:br Bulgarian:bg Burmese:my Catalan:ca Valencian:ca Chamorro:ch \
		Chechen:ce Chinese:zh ChurchSlavic:cu OldSlavonic:cu ChurchSlavonic:cu OldBulgarian:cu \
		OldChurchSlavonic:cu Chuvash:cv Cornish:kw Corsican:co Cree:cr Czech:cs Danish:da \
		Divehi:dv Dhivehi:dv Maldivian:dv Dutch:nl Flemish:nl Dzongkha:dz English:en \
		Esperanto:eo Estonian:et Ewe:ee Faroese:fo Fijian:fj Finnish:fi French:fr \
		WesternFrisian:fy Fulah:ff Georgian:ka German:de Gaelic:gd ScottishGaelic:gd \
		Irish:ga Galician:gl Manx:gv Greek:el Guarani:gn Gujarati:gu Haitian:ht HaitianCreole:ht \
		Hausa:ha Hebrew:he Herero:hz Hindi:hi HiriMotu:ho Croatian:hr Hungarian:hu Igbo:ig \
		Icelandic:is Ido:io SichuanYi:ii Nuosu:ii Inuktitut:iu Interlingue:ie Occidental:ie \
		Interlingua:ia Indonesian:id Inupiaq:ik Italian:it Javanese:jv Japanese:ja \
		Kalaallisut:kl Greenlandic:kl Kannada:kn Kashmiri:ks Kanuri:kr Kazakh:kk CentralKhmer:km \
		Kikuyu:ki Gikuyu:ki Kinyarwanda:rw Kirghiz:ky Kyrgyz:ky Komi:kv Kongo:kg Korean:ko \
		Kuanyama:kj Kwanyama:kj Kurdish:ku Lao:lo Latin:la Latvian:lv Limburgan:li Limburger:li \
		Limburgish:li Lingala:ln Lithuanian:lt Luxembourgish:lb Letzeburgesch:lb Luba-Katanga:lu \
		Ganda:lg Macedonian:mk Marshallese:mh Malayalam:ml Maori:mi Marathi:mr Malay:ms \
		Malagasy:mg Maltese:mt Mongolian:mn Nauru:na Navajo:nv Navaho:nv SouthNdebele:nr \
		NorthNdebele:nd Ndonga:ng Nepali:ne NorwegianNynorsk:nn Nynorsk:nn Norwegian:nn \
		Bokmål:nb Norwegian:nb NorwegianBokmål:nb Norwegian:no Chichewa:ny Chewa:ny Nyanja:ny \
		Occitan:oc Provençal:oc Ojibwa:oj Oriya:or Oromo:om Ossetian:os Ossetic:os Panjabi:pa \
		Punjabi:pa Persian:fa Pali:pi Polish:pl Portuguese:pt Pushto:ps Pashto:ps Quechua:qu \
		Romansh:rm Romanian:ro Moldavian:ro Moldovan:ro Rundi:rn Russian:ru Sango:sg Sanskrit:sa \
		Sinhala:si Sinhalese:si Slovak:sk Slovenian:sl NorthernSami:se Samoan:sm Shona:sn \
		Sindhi:sd Somali:so Sotho:st Spanish:es Sardinian:sc Serbian:sr Swati:ss Sundanese:su \
		Swahili:sw Swedish:sv Tahitian:ty Tamil:ta Tatar:tt Telugu:te Tajik:tg Tagalog:tl \
		Thai:th Tibetan:bo Tigrinya:ti Tonga:to Tswana:tn Tsonga:ts Turkmen:tk Turkish:tr \
		Twi:tw Uighur:ug Uyghur:ug Ukrainian:uk Urdu:ur Uzbek:uz Venda:ve Vietnamese:vi \
		Volapük:vo Welsh:cy Walloon:wa Wolof:wo Xhosa:xh Yiddish:yi Yoruba:yo Zhuang:za \
		Chuang:za Zulu:zu \
	)
	local abbr=
	if [[ "${#1}" -eq 2 ]] ; then
		for code in "${codes[@]}" ; do
			if [[ "${code#*:}" == "$1" ]] ; then
				abbr="${code#*:}"
				break
			fi
		done
		if [[ "$abbr" == "" ]] ; then
			__errortext "$koiname: err: invalid ISO-361 language code"
			return 1
		fi
	else
		for code in "${codes[@]}" ; do
			local key="`tr '[A-Z]' '[a-z]' <<< "$code"`"
			local query="`tr '[A-Z]' '[a-z]' <<< "$1"`"
			if [[ "${key%:*}" == "$query" ]] ; then
				abbr="${key#*:}"
				break
			fi
		done
		if [[ "$abbr" == "" ]] ; then
			__errortext "$koiname: err: could not resolve language '$1'"
			return 1
		fi
	fi
	echo "$abbr"
}

# ==================== CLI FUNCTIONS ====================

function init {
	__addarg "-h" "--help" "help" "optional" "" "Set up birdhouse"
	__addarg "" "apikey" "positionalvalue" "required" "" "Your Twitter API key"
	__addarg "" "secretkey" "positionalvalue" "required" "" "Your Twitter API secret key"
	__addarg "-u" "--usefiles" "flag" "optional" "" "Read apikey and secretkey from files"
	__addarg "-f" "--force" "flag" "optional" "" "Force overwrite the existing credentials"
	__parseargs "$@"

	__verifyjq

	if [[ "$force" -eq 0 ]] ; then
		if [[ -d ~/.birdhouse ]] ; then
			__errortext "$koiname: err: birdhouse is already initialized"
			__errortext "  use 'birdhouse init --force' to overwrite the existing credentials"
			return 1
		fi
	fi

	local __apikey=
	local __secretkey=
	if [[ "$usefiles" -eq 1 ]] ; then
		if [[ ! -f "$apikey" ]] ; then __errortext "$koiname: err: no such file '$apikey'" ; return 1 ; fi
		if [[ ! -f "$secretkey" ]] ; then __errortext "$koiname: err: no such file '$secretkey'" ; return 1 ; fi
		__apikey="`cat "$apikey"`"
		__secretkey="`cat "$secretkey"`"
	else
		__apikey="$apikey"
		__secretkey="$secretkey"
	fi

	mkdir -p ~/.birdhouse
	echo "$__apikey" > ~/.birdhouse/auth
	echo "$__secretkey" > ~/.birdhouse/secret

	__generatebearertoken

	echo "Initialized credentials in ~/.birdhouse"
}

function regenerate {
	__addarg "-h" "--help" "help" "optional" "" "Regenerate OAuth bearer token"
	__parseargs "$@"

	__verifyjq

	# verify 'birdhouse init' has been run
	if [[ ! -d ~/.birdhouse ]] ; then
		__errortext "$koiname: err: birdhouse has not been initialized"
		__errortext "  use 'birdhouse init' to initialize"
		return 1
	fi

	# verify API keys are present
	if [[ ! -f ~/.birdhouse/auth || ! -f ~/.birdhouse/secret ]] ; then
		__errortext "$koiname: err: missing credential files in ~/.birdhouse"
		__errortext "  use 'birdhouse init --force' to reinitialize"
		return 1
	fi

	__generatebearertoken
}

function listen {
	__addarg "-h" "--help" "help" "optional" "" "Listen to a bird (a Twitter user) or hashtag"
	__addarg "" "source" "positionalarray" "required" "" "The bird(s) or hashtag(s) to listen to"
	__addarg "-r" "--refresh" "storevalue" "optional" "1" "The refresh rate, in seconds"
	__addarg "-o" "--omitreplies" "flag" "optional" "" "Omit replies"
	__addarg "-a" "--absolute" "flag" "optional" "" "Use absolute timestamps"
	__addarg "-u" "--url" "flag" "optional" "" "Include a URL link to the tweet"
	__addarg "-p" "--popular" "flag" "optional" "" "Only show popular tweets"
	__addarg "-l" "--language" "storevalue" "optional" "" "Only show tweets in a specific language"
	__addarg "-q" "--quiet" "flag" "optional" "" "Silence warnings"
	__parseargs "$@"

	__verifyjq
	__verifycredentials

	# verify each source is formatted correctly
	for item in "${source[@]}" ; do
		if [[ "$item" != @* && "$item" != '#'* ]] ; then
			__errortext "$koiname: err: sources must start with either an '@' for Twitter handles or '#' for hashtags"
			return 1
		fi
	done

	if [[ "$refresh" -lt 1 ]] ; then __errortext "$koiname: err: minimum refresh rate is 1 second" ; return 1 ; fi

	# resolve language
	local langtext=
	if [[ "$language" != "" ]] ; then
		if [[ "${source[@]}" == *@* ]] ; then
			if [[ "$quiet" -eq 0 ]] ; then
				__errortext "warning: --language flag is irrelevant for Twitter handles"
			fi
		fi
		resolvedlanguage=`__resolvelanguage "$language"`
		if [[ "$resolvedlanguage" == "" ]] ; then return 1 ; fi
		langtext="&lang=${resolvedlanguage}"
	fi

	# set trap to exit cleanly
	trap __listenexit EXIT

	# set loading text
	local populartext=
	if [[ "$popular" -eq 1 ]] ; then
		populartext="popular "
	fi
	local handletext=
	local hashtagtext=
	for item in "${source[@]}" ; do
		if [[ "${item:0:1}" == "@" ]] ; then
			if [[ "$handletext" == "" ]] ; then
				handletext="by ${item}"
			else
				handletext="${handletext} + ${item}"
			fi
		else
			if [[ "$hashtagtext" == "" ]] ; then
				hashtagtext="for ${item}"
			else
				hashtagtext="${hashtagtext} + ${item}"
			fi
		fi
	done
	if [[ "$handletext" != "" && "$hashtagtext" != "" ]] ; then
		hashtagtext=", ${hashtagtext}"
	fi
	echo "Streaming ${populartext}tweets ${handletext}${hashtagtext}"

	# start stream
	local seentweets=
	while : ; do
		local tweetbuffer=( )
		local timestamps=( )
		local apiendpoint=
		for item in "${source[@]}" ; do
			# configure API endpoint
			if [[ "${item:0:1}" == "@" ]] ; then
				apiendpoint="https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=${item:1}&tweet_mode=extended"
				if [[ "$omitreplies" -eq 1 ]] ; then
					apiendpoint="${apiendpoint}&exclude_replies=true"
				fi
				if [[ "$popular" -eq 1 ]] ; then
					apiendpoint="${apiendpoint}&count=50&result_type=popular"
				else
					apiendpoint="${apiendpoint}&count=10"
				fi
			else
				apiendpoint="https://api.twitter.com/1.1/search/tweets.json?q=%23${item:1}&tweet_mode=extended"
				if [[ "$popular" -eq 1 ]] ; then
					apiendpoint="${apiendpoint}&count=50&result_type=popular"
				else
					apiendpoint="${apiendpoint}&count=10"
				fi
			fi

			apiendpoint="${apiendpoint}${langtext}"

			# get API response
			response=`__twurl "$apiendpoint"`
			if [[ "${item:0:1}" == '#' ]] ; then
				response="`jq -r '.statuses' <<< "$response"`"
			fi

			for row in $(jq -r '.[] | @base64' <<< "$response") ; do
				function __jq {
					base64 --decode <<< "$row" | jq -r ${1}
				}

				# get timestamp and ID
				local ts=$(__iso2epoch "`__jq '.created_at'`")
				local id=`__jq '.id'`

				# don't repeat found tweets
				if [[ "$seentweets" == *$id* ]] ; then
					continue
				else
					seentweets="${seentweets}$id "
				fi

				# sort array of Tweets from different sources
				local placed=0
				for i in "${!tweetbuffer[@]}" ; do
					if [[ "${timestamps[$i]}" -gt "$ts" ]] ; then
						placed=1
						tweetbuffer=( "${tweetbuffer[@]:0:$i}" "[`base64 --decode <<< "$row"`]" "${tweetbuffer[@]:$i}" )
						timestamps=( "${timestamps[@]:0:$i}" "$ts" "${timestamps[@]:$i}" )
						break
					fi
				done
				if [[ $placed -eq 0 ]] ; then
					tweetbuffer=( "${tweetbuffer[@]}" "[`base64 --decode <<< "$row"`]" )
					timestamps=( "${timestamps[@]}" "$ts" )
				fi
			done
		done

		# process tweets
		for tweet in "${tweetbuffer[@]}" ; do
			__processtweets "$tweet" "$absolute" "$url"
		done

		sleep "$refresh"
	done
}

function chirps {
	__addarg "-h" "--help" "help" "optional" "" "Get chirps (recent tweets) from a bird (a Twitter user) or hashtag"
	__addarg "" "source" "positionalarray" "required" "" "The bird(s) or hashtag(s) to get chirps from"
	__addarg "-n" "--num" "storevalue" "optional" "10" "The number of chirps to get"
	__addarg "-o" "--omitreplies" "flag" "optional" "" "Omit replies (may reduce number of chirps)"
	__addarg "-a" "--absolute" "flag" "optional" "" "Use absolute timestamps"
	__addarg "-u" "--url" "flag" "optional" "" "Include a URL link to the tweet"
	__addarg "-l" "--language" "storevalue" "optional" "" "Only show tweets in a specific language"
	__addarg "-q" "--quiet" "flag" "optional" "" "Silence warnings"
	__parseargs "$@"

	__verifyjq
	__verifycredentials

	# verify each source is formatted correctly
	for item in "${source[@]}" ; do
		if [[ "$item" != @* && "$item" != '#'* ]] ; then
			__errortext "$koiname: err: sources must start with either an '@' for Twitter handles or '#' for hashtags"
			return 1
		fi
	done

	if [[ "$num" -gt 200 ]] ; then __errortext "$koiname: err: cannot get more than 200 chirps per source" ; return 1 ;fi

	# resolve language
	local langtext=
	if [[ "$language" != "" ]] ; then
		if [[ "${source[@]}" == *@* ]] ; then
			if [[ "$quiet" -eq 0 ]] ; then
				__errortext "warning: --language flag is irrelevant for Twitter handles"
			fi
		fi
		resolvedlanguage=`__resolvelanguage "$language"`
		if [[ "$resolvedlanguage" == "" ]] ; then return 1 ; fi
		langtext="&lang=${resolvedlanguage}"
	fi

	# get tweets
	local apiendpoint=
	local response=
	for item in "${source[@]}" ; do
		if [[ "${item:0:1}" == "@" ]] ; then
			apiendpoint="https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=${item:1}&tweet_mode=extended&count=${num}"
			if [[ "$omitreplies" -eq 1 ]] ; then
				apiendpoint="${apiendpoint}&exclude_replies=true"
			fi
			response=`__twurl "$apiendpoint"`
			__processtweets "$response" "$absolute" "$link"
		else
			apiendpoint="https://api.twitter.com/1.1/search/tweets.json?q=%23${item:1}&tweet_mode=extended&count=${num}${langtext}"
			response=`__twurl "$apiendpoint"`
			__processtweets "`jq -r '.statuses' <<< "$response"`" "$absolute" "$url"
		fi
	done
}

function bird {
	__addarg "-h" "--help" "help" "optional" "" "Get information for a bird (a Twitter user)"
	__addarg "" "bird" "positionalarray" "required" "" "The bird(s) to get"
	__addarg "-u" "--url" "flag" "optional" "" "Include a URL link to the bird"
	__parseargs "$@"

	__verifyjq
	__verifycredentials

	# verify handles are formatted correctly
	for handle in "${bird[@]}" ; do
		if [[ "$handle" != @* ]] ; then __errortext "$koiname: err: Twitter handles must start with '@'" ; return 1 ; fi
	done

	for handle in "${bird[@]}" ; do
		# get handle information, parse JSON
		local response=`__twurl "https://api.twitter.com/1.1/users/lookup.json?screen_name=${handle:1}"`
		local name="`jq -r '.[0].name' <<< "$response"`"
		local screenname="`jq -r '.[0].screen_name' <<< "$response"`"
		local location="`jq -r '.[0].location' <<< "$response"`"
		local bio="`jq -r '.[0].description' <<< "$response"`"
		local followers="`jq -r '.[0].followers_count' <<< "$response"`"
		local friends="`jq -r '.[0].friends_count' <<< "$response"`"
		local tweets="`jq -r '.[0].statuses_count' <<< "$response"`"
		local createdat=( `jq -r '.[0].created_at' <<< "$response"` )
		if [[ "$name" == "" || "$name" == "null" ]] && [[ "$screen_name" == "" || "$screen_name" == "null" ]]; then
			return 1
		fi

		# name, screen_name
		echo -ne "${__bold}${name}${__reset} (${__teal}@${screenname}${__reset})"

		# location
		if [[ "$location" != "" ]] ; then
			echo -ne " | ${__italics}${location}${__reset}"
		fi

		# URL
		if [[ "$url" -eq 1 ]] ; then
			echo -e " | ${__lightgrey}https://twitter.com/${screenname}${__reset}"
		else
			echo
		fi

		# bio
		if [[ "$bio" != "" ]] ; then
			echo -e "${__italics}${__lightgrey}${bio}${__reset}"
		fi

		# followers
		if [[ "$followers" != "" ]] ; then
			local __followers=follower
			if [[ "$followers" != "1" ]] ; then
				__followers=followers
			fi
			echo -e "  ${__yellow}${followers}${__reset} ${__followers}"
		fi

		# friends
		if [[ "$friends" != "" ]] ; then
			local __friends=friend
			if [[ "$friends" != "1" ]] ; then
				__friends=friends
			fi
			echo -e "  ${__yellow}${friends}${__reset} ${__friends}"
		fi

		# total number of tweets
		if [[ "$tweets" != "" ]] ; then
			local __tweets=tweet
			if [[ "$tweets" != "1" ]] ; then
				__tweets=tweets
			fi
			echo -e "  ${__yellow}${tweets}${__reset} ${__tweets}"
		fi

		# creation date
		if [[ "$createdat" != "" ]] ; then
			echo -e "  created on ${__teal}${createdat[1]} ${createdat[2]}, ${createdat[5]}${__reset}"
		fi
		echo
	done
}

__koirun "$@"
